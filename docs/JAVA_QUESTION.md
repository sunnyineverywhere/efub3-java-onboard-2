# 자바 핵심 개념 정리 2
<details>
<summary>JAVA의 접근 제어자의 종류와 특징에 대해 설명해주세요.</summary>
<div markdown="1">
자바의 접근 제어자는 private, public, default, protected 4가지이다.<br><br>
1. private<br>
private 접근 제어자로 선언된 멤버에는, 해당 멤버가 선언되어있는 클래스 내에서만 접근할 수 있다. 외부에서는 같은 페키지는 다른 패키지든 어디서도 접근할 수 없다.<br><br>
2. public<br>
public 접근 제어자로 선언된 멤버에는 프로그램 전체 어디에서든 접근할 수 있다.<br>
만약 private 멤버에 접근하고 싶다면, public 메소드를 통해야만 한다.<br><br>
3. default<br>
멤버를 선언할 때 아무런 접근 제어자도 붙이지 않으면 기본값인 default 접근 제어자가 적용된다.<br>
default 멤버에는 해당 멤버와 같은 클래스, 그리고 해당 멤버가 속한 클래스와 같은 패키지에 속한 클래스에서 접근할 수 있다.<br>
다른 패키지에서는 접근할 수 없다. 해당 멤버가 속한 클래스를 상속받은 자식 클래스라도, 다른 패키지에 있다면 해당 멤버에 접근할 수 없다.<br><br>
4. protected<br>
default 멤버의 경우와 비슷하게, 같은 클래스 및 같은 패키지에서 접근할 수 있고 다른 패키지에서는 접근할 수 없다.<br>
하지만, 해당 멤버가 속한 클래스를 상속받은 자식 클래스라면 다른 패키지에 있더라도 해당 멤버에 접근할 수 있다.<br>
</div>
</details>
<br>

<details>
<summary>OOP의 5대 원칙 (SOLID)에 대해 설명해주세요.</summary>
<div markdown="1">
SOLID는 SRP, OCP, LSP, ISP, DIP를 가리킨다.<br><br>
1. SRP<br>
Single Responsibility Principle, 단일 책임 원칙<br>
한 클래스는 하나의 책임만 가져야 한다.<br>
그러나, 하나의 책임이라는 것의 정의는 모호하다. 어느 범위까지를 '하나'라고 할 수 있는가?<br>
이 원칙의 핵심은 '하나'의 정의를 내리는 것이 아니다.<br>
특정 클래스가 너무 많은 역할을 가지고 있어서, 혹은 너무 큰 파급효과를 가지고 있어서, 그 클래스를 변경하는 순간 프로그램의 여러 부분에서 큰일이 난다면 이 원칙을 지키지 못한 것이다.<br>
변경이 있을 때 파급효과가 적어 관리하기가 용이하다면 이 법칙을 잘 지킨 것이다.<br>
책임을 무조건 최대한 잘게 쪼개어 부여하는 게 좋은 것도 아니다. 쓸데없이 너무 조금씩의 책임을 많은 클래스에 분배하면 오히려 효율이 떨어진다.<br>
합의점을 잘 찾아서 책임을 적절히 분배해야 한다.<br><br>
2. OCP<br>
Open/Closed Principle, 개방-폐쇄 원칙<br>
소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.<br>
가장 중요하지만, 언뜻 들으면 말도 안 되는 원칙이다. 애초에 확장을 하려면 기존의 코드에 손을 대야 하는데, 어떻게 변경 없이 확장을 하라는 말인가?<br>
하지만, 스프링은 변경 없이 확장을 할 수 있게 해주는 방법을 제공한다. 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 생성자들이다.<br>
DI, IoC 컨테이너 등이 그러한 역할을 한다.<br><br>
3. LSP<br>
Liskov Substitution Principle, 리스코프 지환 원칙<br>
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.<br>
상위에서 정해놓은 사항을 하위 인스턴스가 마음대로 바꾸지 말아야 한다는 뜻이다.<br>
이 법칙을 잘 치키면 프로젝트 코드 전체에 일관성이 생기고, 사용과 관리가 편리해진다. 프로젝트에 함께 참여하는 개발자들 사이 혼선이 생기는 일도 막을 수 있다.<br><br>
4. ISP<br>
Interface Segregation Principle, 인터페이스 분리 원칙<br>
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.<br>
인터페이스 하나가 여기저기 다양한 다 쓰이게 하지 않고, 각 클라이언트별(역할별)로 각자 다른 인터페이스가 담당하게 잘 쪼개야 한다.<br>
이렇게 해야, 클라이언트 A에 관련된 변경사항이 생겨 인터페이스 A의 코드를 고치더라도 클라이언트 B에는 아무 영향이 없도록 할 수 있다.<br>
따라서 유지보수하기가 좋아진다.<br><br>
5. DIP<br>
Dependency Inversion Principle, 의존관계 역전 원칙<br>
구현체에 의존하지 않고, 인터페이스에만 의존하라는 뜻이다.<br>
이 원칙을 지키면, 전체 코드를 인터페이스에 맞추어 짜놓고, 구현제는 유연하게 갈아끼울 수 있기 때문이다.<br>
코드가 특정 구현체에 의존하게 해놓으면, 구현체가 바뀔 때마다 문제가 발생한다.<br>
</div>
</details>
<br>

<details>
<summary>non-static 멤버와 static 멤버의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
non-static 멤버는, 해당 멤버가 속한 클래스의 인스턴스를 만들어야 메모리(heap 메모리 공간)에 올라가고, 그때부터 사용할 수 있다. 인스턴스를 만들기 전까지 non-static 멤버는 허상에 불과하다.<br>
static 멤버는, 해당 멤버가 속한 클래스가 JVM에 의해 접근당하는 순간 메모리(static 메모리 공간)에 올라간다. 따라서 클래스의 인스턴스를 만들지 않아도, 클래스 접근 시점부터 바로 사용이 가능하다.<br>
즉 static 멤버는 클래스 자체에 속하는 멤버고, non-static 멤버는 클래스를 바탕으로 만들어진 객체에 속하는 멤버다.
</div>
</details>
<br>

<details>
<summary>클래스, 객체, 인스턴스의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
클래스는 설계도와 같다. 객체는 설계도에 맞추어 만들어진 대상을 부르는 말이고, 인스턴스는 서로 다른 객체 하나하나를 가리킨다.<br>
예를 들면 다음과 같다. 신이 인간을 만들기 위해 짜놓은 설계도는 클래스이다. 인간은 객체이다. 그리고 각각의 인간인 영희, 민수, 존은 서로 다른 인스턴스이다.
</div>
</details>
<br>

<details>
<summary>⭐️ 프로세스, 스레드, 멀티프로세스, 멀티스레드에 대해 설명해주세요.</summary>
<div markdown="1">
프로세스는 메모리 상에서 실행 중인 작업을 말한다.<br>
프로세스는 프로그램과는 다르다. 완벽히 정확한 예는 아니지만 예를 들자면, 크롬이라는 프로그램을 실행시켰다고 하자. 크롬 내에서 네이버 접속이라는 작업을 실행하면, 크롬은 프로그램이고 네이버 접속은 프로세스이다.<br>
스레드는 프로세스보다 작은 실행 단위이다. 한 프로세스가 실행되면 프로세스는 런타임메모리 상에서 자신만의 고유한 공간 및 자원을 할당받는다. 프로세스 내의 스레드들은 프로세스가 할당받은 자원 안에서 각자 다른 register와 stack을 할당받는다.<br>
이 register stack 외의 나머지 공간 및 자원은 같은 프로세스 내의 다른 스레드들과 공유한다.<br><br>
멀티 프로세스란 여러 프로세스가 각자 독립된 code, heap, stack, data 공간을 가지면서 동시에 일하는 것이다. 다수의 프로세서가 협력하면서 병렬적으로 작업들을 처리한다.<br>
멀티 스레드란 한 프로세스 안에 여러 스레드를 만들어서 작업을 나누어 수행하는 것이다. 이 경우에는 각자의 스택과 레지스터만 독립되어있고 나머지 자원은 공유한다.<br><br>
멀티 프로세스에서는 작업들이 서로 독립되어있기 때문에 안정적이지만, 이 점 때문에 필요한 자원이 많고 성능이 저하될 수 있다.<br>
멀티 스레드를 사용하면 자원 소모가 적어지지만, 자원을 공유한다는 점 때문에 동기화 문제가 발생할 수 있다. 이 동기화 문제 때문에 성능이 저하되기도 한다.
</div>
</details>
<br>
